<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Lector de Frecuencias (Beta)</title>
  <style>
    body {
      background: black;
      color: lime;
      font-family: monospace;
      text-align: center;
    }
    canvas {
      width: 100%;
      height: 200px;
      background: #111;
      display: block;
      margin: 1em auto;
    }
    .event-log {
      max-height: 200px;
      overflow-y: auto;
      background: #222;
      color: #0ff;
      padding: 10px;
      margin: 10px auto;
      width: 90%;
      border: 1px solid #0ff;
    }
  </style>
</head>
<body>
  <h1>ðŸŽ§ Lector de Frecuencias</h1>
  <canvas id="canvas" width="1024" height="200"></canvas>
  <div class="event-log" id="eventLog">Esperando eventos clave...</div>

  <script>
    const FRECUENCIAS_CLAVE = [432, 440, 528, 1000];
    const TOLERANCIA_HZ = 5; // +/- Hz
    const DURACION_UMBRAL_MS = 1000;

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const eventLog = document.getElementById('eventLog');

    let detecciones = {};

    navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const source = audioCtx.createMediaStreamSource(stream);
      const analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      source.connect(analyser);

      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);

      function frecuenciaDeBin(bin) {
        return bin * audioCtx.sampleRate / analyser.fftSize;
      }

      function loop() {
        requestAnimationFrame(loop);
        analyser.getByteFrequencyData(dataArray);

        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let i = 0; i < bufferLength; i++) {
          const valor = dataArray[i];
          const x = i * canvas.width / bufferLength;
          const y = canvas.height - valor;
          const freq = frecuenciaDeBin(i);

          let color = 'lime';
          FRECUENCIAS_CLAVE.forEach(clave => {
            if (Math.abs(freq - clave) < TOLERANCIA_HZ && valor > 100) {
              color = 'red';
              // captura de patrÃ³n por duraciÃ³n
              if (!detecciones[clave]) {
                detecciones[clave] = { inicio: Date.now(), activo: true };
              } else if (detecciones[clave].activo && Date.now() - detecciones[clave].inicio > DURACION_UMBRAL_MS) {
                logEvento(`PatrÃ³n detectado: ${clave} Hz mantenido > ${DURACION_UMBRAL_MS / 1000}s`);
                detecciones[clave].activo = false;
              }
            }
          });

          ctx.fillStyle = color;
          ctx.fillRect(x, y, 2, canvas.height);
        }

        // limpieza de eventos viejos
        for (let clave in detecciones) {
          if (Date.now() - detecciones[clave].inicio > DURACION_UMBRAL_MS + 2000) {
            delete detecciones[clave];
          }
        }
      }

      loop();
    });

    function logEvento(texto) {
      const time = new Date().toLocaleTimeString();
      eventLog.innerHTML = `[${time}] ${texto}<br>` + eventLog.innerHTML;
    }
  </script>
</body>
</html>
